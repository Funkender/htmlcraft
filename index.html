
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>HTML Craft by Funkelnder</title>

</head> <link rel="stylesheet" href="style.css">

<body>
  <div id="crosshair"></div>
  <div id="info">Loading...</div>
  <div id="blockInfo">Placing: GREEN</div>

  <!-- Buttons -->
  <div id="btnBreak" class="btn">Break</div>
  <div id="btnPlace" class="btn">Place</div>
  <div id="btn1" class="btn">1 (Brown)</div>
  <div id="btn2" class="btn">2 (Green)</div>
  <button id="btnRTX" style="position:absolute; bottom:10px; right:10px;">
  RTX Toggle
</button>


  <!-- Joysticks -->
  <div id="joyMove" class="joystick"><div class="stick"></div></div>
  <div id="joyLook" class="joystick"><div class="stick"></div></div>

  <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.162.0/build/three.module.js" } }
  </script>

  <script type="module">
    import * as THREE from "three";

    // --- Globale Variablen ---
const CHUNK_SIZE = 8;
const VISIBLE_DISTANCE = 6;
const loadedChunks = new Map();

// Materialien
const matGreen = new THREE.MeshLambertMaterial({ color: 0x006400 });
const matBrown = new THREE.MeshLambertMaterial({ color: 0x8B4513 });

// Heightmap für Kollision
const heightMap = new Map();

// Hilfsfunktion für Chunk-Key
function chunkKey(x, z) {
  return `${x},${z}`;
}

// --- Terrain Generator mit Instancing ---
function generateChunk(scene, cx, cz) {
  const chunk = new THREE.Group();
  const geo = new THREE.BoxGeometry(1, 1, 1);

  // Ein Material für alle Instanzen
  const matBlock = new THREE.MeshLambertMaterial({ color: 0x228B22 });

  // InstancedMesh vorbereiten
  const maxInstances = CHUNK_SIZE * CHUNK_SIZE;
  const instancedMesh = new THREE.InstancedMesh(geo, matBlock, maxInstances);
  instancedMesh.castShadow = true;
  instancedMesh.receiveShadow = true;

  // Terrain-Parameter
  const scaleBase = 0.12;
  const scaleDetail = 0.25;
  const maxHeight = 13;

  // kombinierte Noise-Funktion
  function noise2D(x, z) {
    const base = Math.sin(x * scaleBase) + Math.cos(z * scaleBase);
    const detail = Math.sin(x * scaleDetail * 1.5) * Math.cos(z * scaleDetail);
    const randomOffset = Math.sin((x + z) * 0.05);
    return base + detail * 0.5 + randomOffset * 0.3;
  }

  const dummy = new THREE.Object3D();
  let index = 0;

  // Schleife über alle Blockpositionen im Chunk
  for (let i = 0; i < CHUNK_SIZE; i++) {
    for (let j = 0; j < CHUNK_SIZE; j++) {
      const x = cx * CHUNK_SIZE + i;
      const z = cz * CHUNK_SIZE + j;

      // Höhe berechnen
      const n = noise2D(x, z);
      const h = Math.floor((n + 2) / 4 * maxHeight);

      // Höhe speichern für Kollision
      heightMap.set(`${x},${z}`, h);

      // Dummy setzen
      dummy.position.set(x, h, z);
      dummy.updateMatrix();
      instancedMesh.setMatrixAt(index++, dummy.matrix);
    }
  }

  instancedMesh.count = index;
  instancedMesh.instanceMatrix.needsUpdate = true;

  chunk.add(instancedMesh);
  scene.add(chunk);
  loadedChunks.set(chunkKey(cx, cz), chunk);
}
















function updateVisibleChunks(scene, player) {
  const px = Math.floor(player.position.x / CHUNK_SIZE);
  const pz = Math.floor(player.position.z / CHUNK_SIZE);

  // --- Nachladen ---
  for (let dx = -VISIBLE_DISTANCE; dx <= VISIBLE_DISTANCE; dx++) {
    for (let dz = -VISIBLE_DISTANCE; dz <= VISIBLE_DISTANCE; dz++) {
      const cx = px + dx;
      const cz = pz + dz;
      const key = chunkKey(cx, cz);

      if (!loadedChunks.has(key)) {
        const chunk = generateChunk(scene, cx, cz);
        if (chunk) {
          scene.add(chunk);
          loadedChunks.set(key, chunk);
        }
      }
    }
  }

  // --- Entfernen mit Puffer ---
  const REMOVE_DISTANCE = VISIBLE_DISTANCE + 1; // Puffer
  for (const [key, chunk] of loadedChunks) {
    const [cx, cz] = key.split(",").map(Number);
    if (
      Math.abs(cx - px) > REMOVE_DISTANCE ||
      Math.abs(cz - pz) > REMOVE_DISTANCE
    ) {
      scene.remove(chunk);
      loadedChunks.delete(key);
    }
  }
}









   






// --- FPS Anzeige ---
(function setupFPS() {
  const fpsEl = document.createElement('div');
  fpsEl.style.position = 'fixed';
  fpsEl.style.top = '5px';
  fpsEl.style.right = '5px';
  fpsEl.style.padding = '4px 8px';
  fpsEl.style.background = 'rgba(0,0,0,0.5)';
  fpsEl.style.color = '#0f0';
  fpsEl.style.fontFamily = 'monospace';
  fpsEl.style.fontSize = '14px';
  fpsEl.style.zIndex = '9999';
  fpsEl.textContent = 'FPS: ...';
  document.body.appendChild(fpsEl);

  let lastTime = performance.now();
  let frames = 0;

  function updateFPS() {
    const now = performance.now();
    frames++;
    if (now - lastTime >= 1000) {
      fpsEl.textContent = `FPS: ${frames}`;
      frames = 0;
      lastTime = now;
    }
    requestAnimationFrame(updateFPS);
  }
  updateFPS();
})();


const raycaster = new THREE.Raycaster();

function getTargetBlock(scene, camera) {
  const origin = camera.getWorldPosition(new THREE.Vector3());
  const dir = camera.getWorldDirection(new THREE.Vector3());
  raycaster.set(origin, dir);

  raycaster.near = 0.1;
  raycaster.far = 8; // Reichweite begrenzen

  const hits = raycaster.intersectObjects(scene.children, true);
  return hits.length > 0 ? hits[0] : null;
}






    // --- Init ---
    function init() {
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // --- Licht & Schatten (scharf) ---

// --- Licht & Schatten (scharf) ---
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap; // schärfer als SoftShadow

// Shadow Maps nur alle 15 Sekunden aktualisieren
renderer.shadowMap.autoUpdate = false;
setInterval(() => {
  renderer.shadowMap.needsUpdate = true;
  console.log("Shadow Map aktualisiert");
}, 1);


// Umgebungslicht für Grundhelligkeit
const ambientLight = new THREE.AmbientLight(0xffffff, 0.2); // etwas dunkler, damit Schatten kontrastreich wirken
scene.add(ambientLight);

// Sonnenlicht (DirectionalLight mit Schatten)
const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
sunLight.position.set(50, 60, 50); // etwas tiefer für längere Schatten
sunLight.castShadow = true;

// Schärfere Schatten durch große MapSize
sunLight.shadow.mapSize.width = 4096;
sunLight.shadow.mapSize.height = 4096;

// Schatten-Kamera enger setzen, damit die Auflösung nicht „verwaschen“ wirkt
sunLight.shadow.camera.near = 0.5;
sunLight.shadow.camera.far = 300;
sunLight.shadow.camera.left = -100;
sunLight.shadow.camera.right = 100;
sunLight.shadow.camera.top = 100;
sunLight.shadow.camera.bottom = -100;

scene.add(sunLight);


// Pitch/Yaw Rig
      const yawObject = new THREE.Object3D();
      const pitchObject = new THREE.Object3D();
      yawObject.add(pitchObject);
      pitchObject.add(camera);
      scene.add(yawObject);
      yawObject.position.set(0, 5, 0);

     

      // --- HUD Info ---
const infoEl = document.getElementById('info');
function updateHUD() {
  infoEl.textContent = `Pos: (${yawObject.position.x.toFixed(1)}, ${yawObject.position.y.toFixed(1)}, ${yawObject.position.z.toFixed(1)})`;
}

// --- Buttons pls klapp rc 

// --- Break Button ---
document.getElementById('btnBreak').addEventListener('touchstart', () => {
  const hit = getTargetBlock(scene, camera);
  if (hit) {
    if (!(hit.object instanceof THREE.InstancedMesh)) {
      hit.object.parent?.remove(hit.object);
      console.log("Block entfernt:", hit.object);
    } else {
      console.log("Terrain getroffen – wird nicht entfernt");
    }
  } else {
    console.log("Kein Block getroffen");
  }
});


// --- Place Button ---
document.getElementById('btnPlace').addEventListener('touchstart', () => {
  const hit = getTargetBlock(scene, camera);
  if (hit) {
    // Punkt leicht in Richtung der Normalen verschieben (halbe Einheit)
    const placePos = hit.point.clone().addScaledVector(hit.face.normal, 0.5);

    // In Blockraster einrücken
    placePos.x = Math.round(placePos.x);
    placePos.y = Math.round(placePos.y);
    placePos.z = Math.round(placePos.z);

    // Neuen Block erzeugen
    const block = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), matBrown);
    block.position.copy(placePos);
    block.castShadow = rtxEnabled;
    block.receiveShadow = rtxEnabled;
    scene.add(block);

    console.log("Block gesetzt bei:", placePos);
  } else {
    console.log("Kein Ziel gefunden");
  }
});





// --- RTX Toggle Button ---
document.getElementById('btnRTX').addEventListener('touchstart', () => {
  toggleRTX();
  document.getElementById('blockInfo').innerText = "RTX: " + (rtxEnabled ? "ON" : "OFF");
});

// --- Joystick Werte speichern ---
let moveDX = 0, moveDY = 0;
let lookDX = 0, lookDY = 0;

function setupJoystick(id) {
  const joy = document.getElementById(id);
  const stick = joy.querySelector('.stick');
  let activeTouchId = null;

  ['touchstart', 'touchmove'].forEach(evt => {
    joy.addEventListener(evt, e => e.preventDefault(), { passive: false });
  });

  joy.addEventListener('touchstart', e => {
    const touch = e.changedTouches[0];
    activeTouchId = touch.identifier;
  });

  joy.addEventListener('touchend', e => {
    for (const touch of e.changedTouches) {
      if (touch.identifier === activeTouchId) {
        activeTouchId = null;
        stick.style.top = "30px";
        stick.style.left = "30px";
        if (id === "joyMove") { moveDX = 0; moveDY = 0; }
        if (id === "joyLook") { lookDX = 0; lookDY = 0; }
      }
    }
  });

  joy.addEventListener('touchmove', e => {
    for (const touch of e.touches) {
      if (touch.identifier === activeTouchId) {
        const rect = joy.getBoundingClientRect();
        const dx = touch.clientX - (rect.left + rect.width / 2);
        const dy = touch.clientY - (rect.top + rect.height / 2);
        stick.style.left = (30 + dx * 0.3) + "px";
        stick.style.top  = (30 + dy * 0.3) + "px";
        if (id === "joyMove") { moveDX = dx / rect.width; moveDY = dy / rect.height; }
        if (id === "joyLook") { lookDX = dx / rect.width; lookDY = dy / rect.height; }
      }
    }
  });
}

setupJoystick('joyMove');
setupJoystick('joyLook');

// --- Resize ---
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});





// --- RTX Toggle Setup ---
// Globale Variable
let rtxEnabled = true;

// Funktion zum Umschalten
function toggleRTX() {
  rtxEnabled = !rtxEnabled;

  // Renderer bleibt immer aktiv, sonst initialisiert er keine Shadow-Maps
  renderer.shadowMap.enabled = true;

  // Alle Objekte im Scene-Graph durchgehen
  scene.traverse(obj => {
    if (obj.isMesh) {
      obj.castShadow = rtxEnabled;
      obj.receiveShadow = rtxEnabled;
    }
  });

  console.log("RTX ist jetzt " + (rtxEnabled ? "AN" : "AUS"));
}












      // Hilfsfunktion: Bodenhöhe ermitteln

function getGroundHeight(x, z) {
  return (heightMap.get(`${x},${z}`) ?? 0) + 1;
}


// Hauptloop
function animate() {
  requestAnimationFrame(animate);

  // --- Bewegung (Vorwärts/Rückwärts + Strafe), an Yaw orientiert ---
  const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(yawObject.quaternion);
  const right   = new THREE.Vector3(1, 0, 0).applyQuaternion(yawObject.quaternion);

  // Spieler bewegen
  yawObject.position.addScaledVector(forward, -moveDY * 0.5);
  yawObject.position.addScaledVector(right,   moveDX * 0.5);

  // --- Gravitation ---
  const FALL_SPEED = 0.2; // hier kannst du den Wert anpassen
  yawObject.position.y -= FALL_SPEED;

  // --- Bodenhöhe bestimmen ---
  const px = Math.floor(yawObject.position.x);
  const pz = Math.floor(yawObject.position.z);

  // Heightmap nutzen statt scene.traverse
  const groundY = getGroundHeight(px, pz);

  // Spieler 2 Blöcke über Boden setzen
if (yawObject.position.y < groundY + 2) {
  yawObject.position.y = groundY + 2;
}


  // --- Blicksteuerung ---
  yawObject.rotation.y -= lookDX * 0.05;
  pitchObject.rotation.x -= lookDY * 0.05;

  const maxPitch = Math.PI / 2;
  if (pitchObject.rotation.x >  maxPitch) pitchObject.rotation.x =  maxPitch;
  if (pitchObject.rotation.x < -maxPitch) pitchObject.rotation.x = -maxPitch;

  // --- Sichtbare Chunks aktualisieren ---
  updateVisibleChunks(scene, yawObject);

  // --- HUD aktualisieren ---
  updateHUD();

  // --- Schattenkamera dem Spieler folgen lassen ---
  sunLight.position.set(
    yawObject.position.x + 50,
    yawObject.position.y + 100,
    yawObject.position.z + 50
  );
  sunLight.target.position.copy(yawObject.position);
  sunLight.target.updateMatrixWorld();

  // --- Rendern ---
  renderer.render(scene, camera);
}

// Start der Loop
animate();


}


    // Start
    init();
  </script>
</body>
</html>
