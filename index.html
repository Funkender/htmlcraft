<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Voxel World Touch Edition</title>
  <style>
    body { margin:0; overflow:hidden; background:#000; }
    canvas { display:block; }

    #crosshair {
      position:absolute; top:50%; left:50%;
      width:6px; height:6px; background:#fff;
      border-radius:50%; transform:translate(-50%,-50%);
      z-index:10;
    }
    #info, #blockInfo {
      position:absolute; color:white; font-family:monospace;
      background:rgba(0,0,0,0.5); padding:5px; border-radius:3px;
      z-index:10;
    }
    #info { top:10px; left:10px; font-size:12px; }
    #blockInfo { bottom:10px; left:10px; font-size:14px; }

    .btn {
      position:absolute; bottom:20px; background:#333; color:white;
      padding:10px; border-radius:5px; font-size:14px;
      border:2px solid #555; z-index:20;
    }
    #btnBreak { left:20px; }
    #btnPlace { left:100px; }
    #btn1 { right:20px; bottom:160px; }
    #btn2 { right:20px; bottom:200px; }

    .joystick {
      position:absolute; width:120px; height:120px;
      border-radius:50%; background:rgba(255,255,255,0.1);
      z-index:20;
    }
    .stick {
      position:absolute; width:60px; height:60px;
      border-radius:50%; background:rgba(255,255,255,0.3);
      top:30px; left:30px;
    }
    #joyMove { left:20px; bottom:160px; }
    #joyLook { right:20px; bottom:160px; }
  </style>
</head>
<body>
  <div id="crosshair"></div>
  <div id="info">Loading...</div>
  <div id="blockInfo">Placing: GREEN</div>

  <!-- Buttons -->
  <div id="btnBreak" class="btn">Break</div>
  <div id="btnPlace" class="btn">Place</div>
  <div id="btn1" class="btn">1 (Brown)</div>
  <div id="btn2" class="btn">2 (Green)</div>

  <!-- Joysticks -->
  <div id="joyMove" class="joystick"><div class="stick"></div></div>
  <div id="joyLook" class="joystick"><div class="stick"></div></div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.162.0/build/three.module.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from "three";

    // --- Config ---
    const CHUNK_SIZE = 16;
    const VISIBLE_DISTANCE = 3;
    const loadedChunks = new Map();

    // Materialien
    const matGreen = new THREE.MeshBasicMaterial({color:0x006400});
    const matBrown = new THREE.MeshBasicMaterial({color:0x8B4513});
    let currentMaterial = matGreen;

    // --- Weltgenerierung ---
    function chunkKey(x,z){ return `${x},${z}`; }

    function generateChunk(scene,x,z){
      const geo=new THREE.BoxGeometry(1,1,1);
      const chunk=new THREE.Group();
      for(let i=0;i<CHUNK_SIZE;i++){
        for(let j=0;j<CHUNK_SIZE;j++){
          const mat = (Math.random()<0.75)? matGreen : matBrown;
          const block=new THREE.Mesh(geo,mat);
          block.position.set(x*CHUNK_SIZE+i,0,z*CHUNK_SIZE+j);
          chunk.add(block);
        }
      }
      scene.add(chunk);
      loadedChunks.set(chunkKey(x,z),chunk);
    }

    function updateVisibleChunks(scene,player){
      const px=Math.floor(player.position.x/CHUNK_SIZE);
      const pz=Math.floor(player.position.z/CHUNK_SIZE);
      for(let dx=-VISIBLE_DISTANCE;dx<=VISIBLE_DISTANCE;dx++){
        for(let dz=-VISIBLE_DISTANCE;dz<=VISIBLE_DISTANCE;dz++){
          const cx=px+dx, cz=pz+dz, key=chunkKey(cx,cz);
          if(!loadedChunks.has(key)) generateChunk(scene,cx,cz);
        }
      }
      for(const [key,chunk] of loadedChunks){
        const [cx,cz]=key.split(",").map(Number);
        if(Math.abs(cx-px)>VISIBLE_DISTANCE||Math.abs(cz-pz)>VISIBLE_DISTANCE){
          scene.remove(chunk); loadedChunks.delete(key);
        }
      }
    }

    // --- Init ---
    function init(){
      const scene=new THREE.Scene();
      const camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
      const renderer=new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(window.innerWidth,window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Pitch/Yaw Rig
      const yawObject = new THREE.Object3D();
      const pitchObject = new THREE.Object3D();
      yawObject.add(pitchObject);
      pitchObject.add(camera);
      scene.add(yawObject);
      yawObject.position.set(0,5,0);

      // Buttons Events
      document.getElementById('btnBreak').addEventListener('click',()=>console.log("Break block"));
      document.getElementById('btnPlace').addEventListener('click',()=>console.log("Place block"));

      document.getElementById('btn1').addEventListener('click',()=>{
        currentMaterial = matBrown;
        document.getElementById('blockInfo').innerText="Placing: BROWN";
      });
      document.getElementById('btn2').addEventListener('click',()=>{
        currentMaterial = matGreen;
        document.getElementById('blockInfo').innerText="Placing: GREEN";
      });

      // --- Joystick Werte speichern ---
      let moveDX=0, moveDY=0;
      let lookDX=0, lookDY=0;

      function setupJoystick(id){
        const joy=document.getElementById(id);
        const stick=joy.querySelector('.stick');
        let active=false;
        joy.addEventListener('touchstart',()=>{active=true;});
        joy.addEventListener('touchend',()=>{
          active=false;
          stick.style.top="30px"; stick.style.left="30px";
          if(id==="joyMove"){ moveDX=0; moveDY=0; }
          if(id==="joyLook"){ lookDX=0; lookDY=0; }
        });
        joy.addEventListener('touchmove',e=>{
          if(!active) return;
          const rect=joy.getBoundingClientRect();
          const touch=e.touches[0];
          const dx=touch.clientX-(rect.left+rect.width/2);
          const dy=touch.clientY-(rect.top+rect.height/2);
          stick.style.left=(30+dx*0.3)+"px";
          stick.style.top=(30+dy*0.3)+"px";
          if(id==="joyMove"){ moveDX=dx/rect.width; moveDY=dy/rect.height; }
          if(id==="joyLook"){ lookDX=dx/rect.width; lookDY=dy/rect.height; }
        });
      }

      setupJoystick('joyMove');
      setupJoystick('joyLook');

      function animate(){
        requestAnimationFrame(animate);

        // Bewegung anwenden (Vorw채rts/R체ckw채rts korrigiert)
        const forward = new THREE.Vector3(0,0,-1).applyQuaternion(yawObject.quaternion);
        const right = new THREE.Vector3(1,0,0).applyQuaternion(yawObject.quaternion);
        yawObject.position.addScaledVector(forward, -moveDY*0.5); // Vorzeichen ge채ndert
        yawObject.position.addScaledVector(right, moveDX*0.5);
        if(yawObject.position.y<1) yawObject.position.y=1;

        // Kamera-Look anwenden
        yawObject.rotation.y -= lookDX*0.05;
        pitchObject.rotation.x -= lookDY*0.05;
        const maxPitch=Math.PI/2;
        if(pitchObject.rotation.x>maxPitch) pitchObject.rotation.x=maxPitch;
        if(pitchObject.rotation.x<-maxPitch) pitchObject.rotation.x=-maxPitch;

        updateVisibleChunks(scene,yawObject);
        renderer.render(scene,camera);
      }
      animate();
    }

    // Direktstart
    init();
  </script>
</body>
</html>
