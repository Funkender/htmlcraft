
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Voxel World Touch Edition</title>

</head> <link rel="stylesheet" href="style.css">

<body>
  <div id="crosshair"></div>
  <div id="info">Loading...</div>
  <div id="blockInfo">Placing: GREEN</div>

  <!-- Buttons -->
  <div id="btnBreak" class="btn">Break</div>
  <div id="btnPlace" class="btn">Place</div>
  <div id="btn1" class="btn">1 (Brown)</div>
  <div id="btn2" class="btn">2 (Green)</div>

  <!-- Joysticks -->
  <div id="joyMove" class="joystick"><div class="stick"></div></div>
  <div id="joyLook" class="joystick"><div class="stick"></div></div>

  <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.162.0/build/three.module.js" } }
  </script>

  <script type="module">
    import * as THREE from "three";

    // --- Config ---
    const CHUNK_SIZE = 16;
    const VISIBLE_DISTANCE = 3;
    const loadedChunks = new Map();

    // Materialien (beleuchtet)
    const matGreen = new THREE.MeshLambertMaterial({ color: 0x006400 });
    const matBrown = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
    let currentMaterial = matGreen;

    function chunkKey(x, z) {
  return `${x},${z}`;
}

function generateChunk(scene, x, z) {
  const geo = new THREE.BoxGeometry(1, 1, 1);
  const chunk = new THREE.Group();

  // --- Layer 1: komplett gefüllt ---
  for (let i = 0; i < CHUNK_SIZE; i++) {
    for (let j = 0; j < CHUNK_SIZE; j++) {
      const worldX = x * CHUNK_SIZE + i;
      const worldZ = z * CHUNK_SIZE + j;
      const block = new THREE.Mesh(geo, matBrown);
      block.position.set(worldX, 0, worldZ); // Layer 1 = y=0
      chunk.add(block);
    }
  }

  // --- Layer 2: mit bis zu 2 Löchern ---
  const holes = [];
  const numHoles = Math.floor(Math.random() * 3); // 0, 1 oder 2 Löcher

  for (let h = 0; h < numHoles; h++) {
    const holeSize = Math.floor(3 + Math.random() * 9); // 3..11
    const holeX = x * CHUNK_SIZE + Math.floor(Math.random() * (CHUNK_SIZE - holeSize));
    const holeZ = z * CHUNK_SIZE + Math.floor(Math.random() * (CHUNK_SIZE - holeSize));
    holes.push({ holeX, holeZ, holeSize });
  }

  for (let i = 0; i < CHUNK_SIZE; i++) {
    for (let j = 0; j < CHUNK_SIZE; j++) {
      const worldX = x * CHUNK_SIZE + i;
      const worldZ = z * CHUNK_SIZE + j;

      // prüfen ob in einem Loch
      let inHole = false;
      for (const hole of holes) {
        if (
          worldX >= hole.holeX && worldX < hole.holeX + hole.holeSize &&
          worldZ >= hole.holeZ && worldZ < hole.holeZ + hole.holeSize
        ) {
          inHole = true;
          break;
        }
      }

      if (!inHole) {
        const block = new THREE.Mesh(geo, matGreen);
        block.position.set(worldX, 1, worldZ); // Layer 2 = y=1
        chunk.add(block);
      }
    }
  }

  scene.add(chunk);
  loadedChunks.set(chunkKey(x, z), chunk);
}








    function updateVisibleChunks(scene, player) {
      const px = Math.floor(player.position.x / CHUNK_SIZE);
      const pz = Math.floor(player.position.z / CHUNK_SIZE);

      // Nachladen
      for (let dx = -VISIBLE_DISTANCE; dx <= VISIBLE_DISTANCE; dx++) {
        for (let dz = -VISIBLE_DISTANCE; dz <= VISIBLE_DISTANCE; dz++) {
          const cx = px + dx, cz = pz + dz, key = chunkKey(cx, cz);
          if (!loadedChunks.has(key)) generateChunk(scene, cx, cz);
        }
      }
      // Entfernen
      for (const [key, chunk] of loadedChunks) {
        const [cx, cz] = key.split(",").map(Number);
        if (Math.abs(cx - px) > VISIBLE_DISTANCE || Math.abs(cz - pz) > VISIBLE_DISTANCE) {
          scene.remove(chunk);
          loadedChunks.delete(key);
        }
      }
    }

    // --- Init ---
    function init() {
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Licht
      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(10, 20, 10);
      scene.add(light);
      scene.add(new THREE.AmbientLight(0x222222));

      // Pitch/Yaw Rig
      const yawObject = new THREE.Object3D();
      const pitchObject = new THREE.Object3D();
      yawObject.add(pitchObject);
      pitchObject.add(camera);
      scene.add(yawObject);
      yawObject.position.set(0, 5, 0);

      // HUD Info
      const infoEl = document.getElementById('info');
      function updateHUD() {
        infoEl.textContent = `Pos: (${yawObject.position.x.toFixed(1)}, ${yawObject.position.y.toFixed(1)}, ${yawObject.position.z.toFixed(1)})`;
      }

      // Buttons (ohne Raycast)
      document.getElementById('btnBreak').addEventListener('click', () => {
        // Entfernt Block auf exakt der Integer-Position des Spielers (auf y=0 Ebene bevorzugt)
        const pos = yawObject.position.clone().floor();
        // Falls Spieler über Boden schwebt, nur Bodenebene prüfen
        pos.y = 0;
        // passenden Mesh finden und entfernen
        let toRemove = null;
        scene.traverse(obj => {
          if (toRemove) return;
          if (obj.isMesh && obj.position.x === pos.x && obj.position.y === pos.y && obj.position.z === pos.z) {
            toRemove = obj;
          }
        });
        if (toRemove) {
          toRemove.parent?.remove(toRemove);
        }
      });

      document.getElementById('btnPlace').addEventListener('click', () => {
        // Setzt Block eine Einheit vor dem Spieler, gerastert auf ganze Koordinaten
        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(yawObject.quaternion);
        const pos = yawObject.position.clone().add(forward).round();
        pos.y = 0; // auf Bodenebene platzieren
        const block = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), currentMaterial);
        block.position.copy(pos);
        scene.add(block);
      });

      document.getElementById('btn1').addEventListener('click', () => {
        currentMaterial = matBrown;
        document.getElementById('blockInfo').innerText = "Placing: BROWN";
      });
      document.getElementById('btn2').addEventListener('click', () => {
        currentMaterial = matGreen;
        document.getElementById('blockInfo').innerText = "Placing: GREEN";
      });

      // --- Joystick Werte speichern ---
      let moveDX = 0, moveDY = 0;
      let lookDX = 0, lookDY = 0;

      function setupJoystick(id) {
        const joy = document.getElementById(id);
        const stick = joy.querySelector('.stick');
        let activeTouchId = null;

        // iOS: Default Scrolling/Zoom verhindern
        ['touchstart', 'touchmove'].forEach(evt => {
          joy.addEventListener(evt, e => e.preventDefault(), { passive: false });
        });

        joy.addEventListener('touchstart', e => {
          const touch = e.changedTouches[0];
          activeTouchId = touch.identifier;
        });

        joy.addEventListener('touchend', e => {
          for (const touch of e.changedTouches) {
            if (touch.identifier === activeTouchId) {
              activeTouchId = null;
              stick.style.top = "30px";
              stick.style.left = "30px";
              if (id === "joyMove") { moveDX = 0; moveDY = 0; }
              if (id === "joyLook") { lookDX = 0; lookDY = 0; }
            }
          }
        });

        joy.addEventListener('touchmove', e => {
          for (const touch of e.touches) {
            if (touch.identifier === activeTouchId) {
              const rect = joy.getBoundingClientRect();
              const dx = touch.clientX - (rect.left + rect.width / 2);
              const dy = touch.clientY - (rect.top + rect.height / 2);
              // visueller Offset
              stick.style.left = (30 + dx * 0.3) + "px";
              stick.style.top  = (30 + dy * 0.3) + "px";
              // normierte Werte
              if (id === "joyMove") { moveDX = dx / rect.width; moveDY = dy / rect.height; }
              if (id === "joyLook") { lookDX = dx / rect.width; lookDY = dy / rect.height; }
            }
          }
        });
      }

      setupJoystick('joyMove');
      setupJoystick('joyLook');

      // Resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Hauptloop
      function animate() {
        requestAnimationFrame(animate);

        // Bewegung (Vorwärts/Rückwärts + Strafe), an Yaw orientiert
        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(yawObject.quaternion);
        const right = new THREE.Vector3(1, 0, 0).applyQuaternion(yawObject.quaternion);
        yawObject.position.addScaledVector(forward, -moveDY * 0.5);
        yawObject.position.addScaledVector(right, moveDX * 0.5);
        if (yawObject.position.y < 1) yawObject.position.y = 1;

        // Look
        yawObject.rotation.y -= lookDX * 0.05;
        pitchObject.rotation.x -= lookDY * 0.05;
        const maxPitch = Math.PI / 2;
        if (pitchObject.rotation.x > maxPitch) pitchObject.rotation.x = maxPitch;
        if (pitchObject.rotation.x < -maxPitch) pitchObject.rotation.x = -maxPitch;

        // Chunks
        updateVisibleChunks(scene, yawObject);

        // HUD
        updateHUD();

        renderer.render(scene, camera);
      }
      animate();
    }

    // Start
    init();
  </script>
</body>
</html>
