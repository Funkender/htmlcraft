
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Voxel World Touch Edition</title>

</head> <link rel="stylesheet" href="style.css">

<body>
  <div id="crosshair"></div>
  <div id="info">Loading...</div>
  <div id="blockInfo">Placing: GREEN</div>

  <!-- Buttons -->
  <div id="btnBreak" class="btn">Break</div>
  <div id="btnPlace" class="btn">Place</div>
  <div id="btn1" class="btn">1 (Brown)</div>
  <div id="btn2" class="btn">2 (Green)</div>

  <!-- Joysticks -->
  <div id="joyMove" class="joystick"><div class="stick"></div></div>
  <div id="joyLook" class="joystick"><div class="stick"></div></div>

  <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.162.0/build/three.module.js" } }
  </script>

  <script type="module">
    import * as THREE from "three";

    // --- Config ---
    const CHUNK_SIZE = 8;
    const VISIBLE_DISTANCE = 6;
    const loadedChunks = new Map();

    // Materialien (beleuchtet)
    const matGreen = new THREE.MeshLambertMaterial({ color: 0x006400 });
    const matBrown = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
    let currentMaterial = matGreen;

    function chunkKey(x, z) {
  return `${x},${z}`;
}

// --- Simpler Terrain Generator: nur sichtbare Blöcke, Chunk 8x8, Höhe 22 ---
function generateChunk(scene, cx, cz) {
  const chunk = new THREE.Group();
  const geo = new THREE.BoxGeometry(1,1,1);

  // Materialien für jede Fläche: [right, left, top, bottom, front, back]
  const blockMaterials = [
    matBrown, // right
    matBrown, // left
    matGreen, // top
    matBrown, // bottom
    matBrown, // front
    matBrown  // back
  ];

  // Terrain-Parameter
  const scale = 0.15;   // Hügelbreite
  const maxHeight = 22; // maximale Höhe

  // einfache Noise-Funktion
  function noise2D(x, z) {
    return Math.sin(x * scale) + Math.cos(z * scale);
  }

  for (let i = 0; i < 8; i++) {          // CHUNK_SIZE = 8
    for (let j = 0; j < 8; j++) {
      const x = cx * 8 + i;
      const z = cz * 8 + j;

      // Höhe berechnen
      const n = noise2D(x, z);
      const h = Math.floor((n + 2) / 4 * maxHeight);

      // Nur den obersten Block setzen
      const block = new THREE.Mesh(geo, blockMaterials);
      block.position.set(x, h, z);
      chunk.add(block);
    }
  }

  scene.add(chunk);
  loadedChunks.set(chunkKey(cx, cz), chunk);
}






function updateVisibleChunks(scene, player) {
  const px = Math.floor(player.position.x / CHUNK_SIZE);
  const pz = Math.floor(player.position.z / CHUNK_SIZE);

  // --- Nachladen ---
  for (let dx = -VISIBLE_DISTANCE; dx <= VISIBLE_DISTANCE; dx++) {
    for (let dz = -VISIBLE_DISTANCE; dz <= VISIBLE_DISTANCE; dz++) {
      const cx = px + dx;
      const cz = pz + dz;
      const key = chunkKey(cx, cz);

      if (!loadedChunks.has(key)) {
        const chunk = generateChunk(scene, cx, cz);
        if (chunk) {
          scene.add(chunk);
          loadedChunks.set(key, chunk);
        }
      }
    }
  }

  // --- Entfernen mit Puffer ---
  const REMOVE_DISTANCE = VISIBLE_DISTANCE + 1; // Puffer
  for (const [key, chunk] of loadedChunks) {
    const [cx, cz] = key.split(",").map(Number);
    if (
      Math.abs(cx - px) > REMOVE_DISTANCE ||
      Math.abs(cz - pz) > REMOVE_DISTANCE
    ) {
      scene.remove(chunk);
      loadedChunks.delete(key);
    }
  }
}








   






// --- FPS Anzeige ---
(function setupFPS() {
  const fpsEl = document.createElement('div');
  fpsEl.style.position = 'fixed';
  fpsEl.style.top = '5px';
  fpsEl.style.right = '5px';
  fpsEl.style.padding = '4px 8px';
  fpsEl.style.background = 'rgba(0,0,0,0.5)';
  fpsEl.style.color = '#0f0';
  fpsEl.style.fontFamily = 'monospace';
  fpsEl.style.fontSize = '14px';
  fpsEl.style.zIndex = '9999';
  fpsEl.textContent = 'FPS: ...';
  document.body.appendChild(fpsEl);

  let lastTime = performance.now();
  let frames = 0;

  function updateFPS() {
    const now = performance.now();
    frames++;
    if (now - lastTime >= 1000) {
      fpsEl.textContent = `FPS: ${frames}`;
      frames = 0;
      lastTime = now;
    }
    requestAnimationFrame(updateFPS);
  }
  updateFPS();
})();







    // --- Init ---
    function init() {
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Licht
      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(10, 20, 10);
      scene.add(light);
      scene.add(new THREE.AmbientLight(0x222222));

      // Pitch/Yaw Rig
      const yawObject = new THREE.Object3D();
      const pitchObject = new THREE.Object3D();
      yawObject.add(pitchObject);
      pitchObject.add(camera);
      scene.add(yawObject);
      yawObject.position.set(0, 5, 0);

      // HUD Info
      const infoEl = document.getElementById('info');
      function updateHUD() {
        infoEl.textContent = `Pos: (${yawObject.position.x.toFixed(1)}, ${yawObject.position.y.toFixed(1)}, ${yawObject.position.z.toFixed(1)})`;
      }

      // Buttons (ohne Raycast)
      document.getElementById('btnBreak').addEventListener('click', () => {
        // Entfernt Block auf exakt der Integer-Position des Spielers (auf y=0 Ebene bevorzugt)
        const pos = yawObject.position.clone().floor();
        // Falls Spieler über Boden schwebt, nur Bodenebene prüfen
        pos.y = 0;
        // passenden Mesh finden und entfernen
        let toRemove = null;
        scene.traverse(obj => {
          if (toRemove) return;
          if (obj.isMesh && obj.position.x === pos.x && obj.position.y === pos.y && obj.position.z === pos.z) {
            toRemove = obj;
          }
        });
        if (toRemove) {
          toRemove.parent?.remove(toRemove);
        }
      });

      document.getElementById('btnPlace').addEventListener('click', () => {
        // Setzt Block eine Einheit vor dem Spieler, gerastert auf ganze Koordinaten
        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(yawObject.quaternion);
        const pos = yawObject.position.clone().add(forward).round();
        pos.y = 0; // auf Bodenebene platzieren
        const block = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), currentMaterial);
        block.position.copy(pos);
        scene.add(block);
      });

      document.getElementById('btn1').addEventListener('click', () => {
        currentMaterial = matBrown;
        document.getElementById('blockInfo').innerText = "Placing: BROWN";
      });
      document.getElementById('btn2').addEventListener('click', () => {
        currentMaterial = matGreen;
        document.getElementById('blockInfo').innerText = "Placing: GREEN";
      });

      // --- Joystick Werte speichern ---
      let moveDX = 0, moveDY = 0;
      let lookDX = 0, lookDY = 0;

      function setupJoystick(id) {
        const joy = document.getElementById(id);
        const stick = joy.querySelector('.stick');
        let activeTouchId = null;

        // iOS: Default Scrolling/Zoom verhindern
        ['touchstart', 'touchmove'].forEach(evt => {
          joy.addEventListener(evt, e => e.preventDefault(), { passive: false });
        });

        joy.addEventListener('touchstart', e => {
          const touch = e.changedTouches[0];
          activeTouchId = touch.identifier;
        });

        joy.addEventListener('touchend', e => {
          for (const touch of e.changedTouches) {
            if (touch.identifier === activeTouchId) {
              activeTouchId = null;
              stick.style.top = "30px";
              stick.style.left = "30px";
              if (id === "joyMove") { moveDX = 0; moveDY = 0; }
              if (id === "joyLook") { lookDX = 0; lookDY = 0; }
            }
          }
        });

        joy.addEventListener('touchmove', e => {
          for (const touch of e.touches) {
            if (touch.identifier === activeTouchId) {
              const rect = joy.getBoundingClientRect();
              const dx = touch.clientX - (rect.left + rect.width / 2);
              const dy = touch.clientY - (rect.top + rect.height / 2);
              // visueller Offset
              stick.style.left = (30 + dx * 0.3) + "px";
              stick.style.top  = (30 + dy * 0.3) + "px";
              // normierte Werte
              if (id === "joyMove") { moveDX = dx / rect.width; moveDY = dy / rect.height; }
              if (id === "joyLook") { lookDX = dx / rect.width; lookDY = dy / rect.height; }
            }
          }
        });
      }

      setupJoystick('joyMove');
      setupJoystick('joyLook');

      // Resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });



// --- Kamera-Offset ---
(function setupCameraOffset() {
  const OFFSET_Y = 2; // Höhe über Spieler

  function updateCameraOffset() {
    camera.position.y = OFFSET_Y;
  }

  const oldAnimate = animate;
  animate = function() {
    oldAnimate();
    updateCameraOffset();
  };
})();




      // Hilfsfunktion: Bodenhöhe ermitteln
function getGroundHeight(scene, x, z) {
  let maxY = 0;
  scene.traverse(obj => {
    if (obj.isMesh && obj.position.x === x && obj.position.z === z) {
      if (obj.position.y > maxY) maxY = obj.position.y;
    }
  });
  return maxY + 1; // +1 damit der Spieler über dem Block steht
}

// Hauptloop
function animate() {
  requestAnimationFrame(animate);

  // Bewegung (Vorwärts/Rückwärts + Strafe), an Yaw orientiert
  const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(yawObject.quaternion);
  const right = new THREE.Vector3(1, 0, 0).applyQuaternion(yawObject.quaternion);
  yawObject.position.addScaledVector(forward, -moveDY * 0.5);
  yawObject.position.addScaledVector(right, moveDX * 0.5);

  // Gravitation
  yawObject.position.y -= 0.1; // Fallgeschwindigkeit
  const px = Math.floor(yawObject.position.x);
  const pz = Math.floor(yawObject.position.z);
  const groundY = getGroundHeight(scene, px, pz);
  if (yawObject.position.y < groundY) {
    yawObject.position.y = groundY;
  

  // Look
  yawObject.rotation.y -= lookDX * 0.05;
  pitchObject.rotation.x -= lookDY * 0.05;
  const maxPitch = Math.PI / 2;
  if (pitchObject.rotation.x > maxPitch) pitchObject.rotation.x = maxPitch;
  if (pitchObject.rotation.x < -maxPitch) pitchObject.rotation.x = -maxPitch;

}

        // Chunks
        updateVisibleChunks(scene, yawObject);

        // HUD
        updateHUD();

        renderer.render(scene, camera);
      }
      animate();
    }

    // Start
    init();
  </script>
</body>
</html>
